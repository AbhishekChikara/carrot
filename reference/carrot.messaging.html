<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>carrot.messaging &mdash; Carrot v0.4.0-pre1 documentation</title>
    <link rel="stylesheet" href="../static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    '../',
      VERSION:     '0.4.0-pre1',
      COLLAPSE_MODINDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="Carrot v0.4.0-pre1 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
    <link rel="next" title="carrot.backends" href="carrot.backends.html" />
    <link rel="prev" title="carrot.connection" href="carrot.connection.html" /> 
  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
	<h1><a href="../index.html">Carrot v0.4.0-pre1 documentation</a></h1>
	<div class="rel">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a> |
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |
          <a href="carrot.backends.html" title="carrot.backends"
             accesskey="N">next</a> |
          <a href="carrot.connection.html" title="carrot.connection"
             accesskey="P">previous</a>
	</div>
      </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
	<div class="document">
	  <div class="documentwrapper">
	    <div class="bodywrapper">
	      <div class="body">
		
  <div class="section" id="module-carrot.messaging">
<h1>carrot.messaging<a class="headerlink" href="#module-carrot.messaging" title="Permalink to this headline">¶</a></h1>
<p>The introduction to carrot that was here previously has been moved
to the <a class="reference external" href="http://ask.github.com/carrot/introduction.html#example">introduction</a> page.</p>
<p>carrot.messaging</p>
<dl class="class">
<dt id="carrot.messaging.Consumer">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Consumer</tt><big>(</big><em>connection</em>, <em>queue=None</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Message consumer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Consumer.connection" class="reference internal" href="#carrot.messaging.Consumer.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>queue</em> &#8211; see <a title="carrot.messaging.Consumer.queue" class="reference internal" href="#carrot.messaging.Consumer.queue"><tt class="xref docutils literal"><span class="pre">queue</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Consumer.exchange" class="reference internal" href="#carrot.messaging.Consumer.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>durable</em> &#8211; see <a title="carrot.messaging.Consumer.durable" class="reference internal" href="#carrot.messaging.Consumer.durable"><tt class="xref docutils literal"><span class="pre">durable</span></tt></a>.</li>
<li><em>auto_delete</em> &#8211; see <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.</li>
<li><em>exclusive</em> &#8211; see <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a>.</li>
<li><em>exchange_type</em> &#8211; see <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a>.</li>
<li><em>decoder</em> &#8211; see <a title="carrot.messaging.Consumer.decoder" class="reference internal" href="#carrot.messaging.Consumer.decoder"><tt class="xref docutils literal"><span class="pre">decoder</span></tt></a>.</li>
<li><em>backend</em> &#8211; see <a title="carrot.messaging.Consumer.backend" class="reference internal" href="#carrot.messaging.Consumer.backend"><tt class="xref docutils literal"><span class="pre">backend</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Consumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Consumer.connection" title="Permalink to this definition">¶</a></dt>
<dd>A <a title="carrot.connection.AMQPConnection" class="reference external" href="carrot.connection.html#carrot.connection.AMQPConnection"><tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt></a> instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.queue">
<tt class="descname">queue</tt><a class="headerlink" href="#carrot.messaging.Consumer.queue" title="Permalink to this definition">¶</a></dt>
<dd>Name of the queue.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange the queue binds to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Consumer.routing_key" title="Permalink to this definition">¶</a></dt>
<dd><p>The routing key (if any). The interpretation of the routing key
depends on the value of the <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a> attribute:</p>
<blockquote>
<ul>
<li><p class="first">direct exchange</p>
<blockquote>
<p>Matches if the routing key property of the message and
the <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a> attribute are identical.</p>
</blockquote>
</li>
<li><p class="first">fanout exchange</p>
<blockquote>
<p>Always matches, even if the binding does not have a key.</p>
</blockquote>
</li>
<li><p class="first">topic exchange</p>
<blockquote>
<p>Matches the routing key property of the message by a primitive
pattern matching scheme. The message routing key then consists
of words separated by dots (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>, like domain names), and
two special characters are available; star (<tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>) and hash
(<tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>). The star matches any word, and the hash matches
zero or more words. For example <tt class="docutils literal"><span class="pre">&quot;*.stock.#&quot;</span></tt> matches the
routing keys <tt class="docutils literal"><span class="pre">&quot;usd.stock&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;eur.stock.db&quot;</span></tt> but not
<tt class="docutils literal"><span class="pre">&quot;stock.nasdaq&quot;</span></tt>.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.durable">
<tt class="descname">durable</tt><a class="headerlink" href="#carrot.messaging.Consumer.durable" title="Permalink to this definition">¶</a></dt>
<dd>Durable exchanges remain active when a server restarts. Non-durable
exchanges (transient exchanges) are purged when a server restarts.
Default is <tt class="xref docutils literal"><span class="pre">True</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_delete">
<tt class="descname">auto_delete</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_delete" title="Permalink to this definition">¶</a></dt>
<dd>If set, the exchange is deleted when all queues have finished
using it. Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exclusive">
<tt class="descname">exclusive</tt><a class="headerlink" href="#carrot.messaging.Consumer.exclusive" title="Permalink to this definition">¶</a></dt>
<dd>Exclusive queues may only be consumed from by the current connection.
When <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a> is on, this also implies <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.
Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange_type">
<tt class="descname">exchange_type</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange_type" title="Permalink to this definition">¶</a></dt>
<dd><p>AMQP defines four default exchange types (routing algorithms) that
covers most of the common messaging use cases. An AMQP broker can
also define additional exchange types, so see your message brokers
manual for more information about available exchange types.</p>
<blockquote>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>direct</p>
<blockquote>
Direct match between the routing key in the message, and the
routing criteria used when a queue is bound to this exchange.</blockquote>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>topic</p>
<blockquote>
Wildcard match between the routing key and the routing pattern
specified in the binding. The routing key is treated as zero
or more words delimited by <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> and supports special
wildcard characters. <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> matches a single word and <tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>
matches zero or more words.</blockquote>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>fanout</p>
<blockquote>
Queues are bound to this exchange with no arguments. Hence any
message sent to this exchange will be forwarded to all queues
bound to this exchange.</blockquote>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>headers</p>
<blockquote>
<p>Queues are bound to this exchange with a table of arguments
containing headers and values (optional). A special argument
named &#8220;x-match&#8221; determines the matching algorithm, where
<tt class="docutils literal"><span class="pre">&quot;all&quot;</span></tt> implies an <tt class="docutils literal"><span class="pre">AND</span></tt> (all pairs must match) and
<tt class="docutils literal"><span class="pre">&quot;any&quot;</span></tt> implies <tt class="docutils literal"><span class="pre">OR</span></tt> (at least one pair must match).</p>
<dl class="docutils">
<dt><em>NOTE</em>: carrot has poor support for header exchanges at</dt>
<dd>this point.</dd>
</dl>
</blockquote>
<p>This description of AMQP exchange types was shamelessly stolen
from the blog post <a class="reference external" href="http://bit.ly/amqp-exchange-types">AMQP in 10 minutes: Part 4</a> by
Rajith Attapattu. Recommended reading.</p>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.decoder">
<tt class="descname">decoder</tt><a class="headerlink" href="#carrot.messaging.Consumer.decoder" title="Permalink to this definition">¶</a></dt>
<dd>A function able to deserialize the message body.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.backend">
<tt class="descname">backend</tt><a class="headerlink" href="#carrot.messaging.Consumer.backend" title="Permalink to this definition">¶</a></dt>
<dd>The messaging backend used. Defaults to the <tt class="docutils literal"><span class="pre">pyamqplib</span></tt> backend.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.callbacks">
<tt class="descname">callbacks</tt><a class="headerlink" href="#carrot.messaging.Consumer.callbacks" title="Permalink to this definition">¶</a></dt>
<dd>List of registered callbacks to trigger when a message is received
by <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises amqplib.client_0_8.channel.AMQPChannelException:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the queue is
exclusive and the queue already exists and is owned by another
connection.</td>
</tr>
</tbody>
</table>
<p>Example Usage</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">Consumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">DjangoAMQPConnection</span><span class="p">(),</span>
<span class="gp">... </span>                    <span class="n">queue</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_message</span><span class="p">(</span><span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got message </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>            <span class="n">message</span><span class="o">.</span><span class="n">delivery_tag</span><span class="p">,</span> <span class="n">message_data</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">process_message</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into receive loop</span>
</pre></div>
</div>
<dl class="method">
<dt id="carrot.messaging.Consumer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.close" title="Permalink to this definition">¶</a></dt>
<dd>Close the channel to the queue.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.discard_all">
<tt class="descname">discard_all</tt><big>(</big><em>filter=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.discard_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all waiting messages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>filter</em> &#8211; A filter function to only discard the messages this
filter returns.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the number of messages discarded.</td>
</tr>
</tbody>
</table>
<p><em>WARNING</em>: All incoming messages will be ignored and not processed.</p>
<p>Example using filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">waiting_feeds_only</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">message_data</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">except</span><span class="p">:</span> <span class="c"># Should probably be more specific.</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;feed&quot;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.fetch">
<tt class="descname">fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the next message waiting on the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance,
or <tt class="xref docutils literal"><span class="pre">None</span></tt> if there&#8217;s no messages to be received.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterqueue">
<tt class="descname">iterqueue</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinite iterator yielding pending messages.</p>
<p>Obviously you shouldn&#8217;t consume the whole iterator at
once, without using a <tt class="docutils literal"><span class="pre">limit</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>limit</em> &#8211; If set, the iterator stops when it has processed
this number of messages in total.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.message_to_python">
<tt class="descname">message_to_python</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.message_to_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode encoded message back to python.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>message</em> &#8211; A <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.process_next">
<tt class="descname">process_next</tt><big>(</big><em>ack=True</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.process_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Processes the next pending message on the queue.</p>
<p>This function tries to fetch a message from the queue, and
if successful passes the message on to <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>ack</em> &#8211; By default, an ack is sent to the server
signifying that the message has been accepted. This means
that the <a title="carrot.backends.base.BaseMessage.ack" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.ack"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage.ack()</span></tt></a> and
<a title="carrot.backends.base.BaseMessage.reject" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.reject"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage.reject()</span></tt></a> methods
on the message object are no longer valid.
If the ack argument is set to <tt class="xref docutils literal"><span class="pre">False</span></tt>, this behaviour is
disabled and the receiver is required to manually handle
acknowledgment.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The resulting <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a>
object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a new message is received by 
running <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</p>
<p>When a message is received, it passes the message on to the
callbacks listed in the <a title="carrot.messaging.Consumer.callbacks" class="reference internal" href="#carrot.messaging.Consumer.callbacks"><tt class="xref docutils literal"><span class="pre">callbacks</span></tt></a> attribute.
You can register callbacks using <a title="carrot.messaging.Consumer.register_callback" class="reference internal" href="#carrot.messaging.Consumer.register_callback"><tt class="xref docutils literal"><span class="pre">register_callback()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>message_data</em> &#8211; The deserialized message data.</li>
<li><em>message</em> &#8211; The <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises NotImplementedError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If no callbacks has been registered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be triggered by <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">callback</span></tt> function must take two arguments:</p>
<blockquote>
<ul>
<li><p class="first">message_data</p>
<blockquote>
<p>The deserialized message data</p>
</blockquote>
</li>
<li><p class="first">message</p>
<blockquote>
<p>The <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Go into consume mode.</p>
<p>This runs an infinite loop, processing all incoming messages
using <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a> to apply the message to all registered
callbacks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Messaging">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Messaging</tt><big>(</big><em>connection</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging" title="Permalink to this definition">¶</a></dt>
<dd><p>A message publisher and consumer.</p>
<dl class="attribute">
<dt id="carrot.messaging.Messaging.consumer_cls">
<tt class="descname">consumer_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.consumer_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Consumer" class="reference internal" href="#carrot.messaging.Consumer"><tt class="xref docutils literal"><span class="pre">Consumer</span></tt></a></dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.publisher_cls">
<tt class="descname">publisher_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.publisher_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Publisher" class="reference internal" href="#carrot.messaging.Publisher"><tt class="xref docutils literal"><span class="pre">Publisher</span></tt></a></dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Publisher">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Publisher</tt><big>(</big><em>connection</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Message publisher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Publisher.connection" class="reference internal" href="#carrot.messaging.Publisher.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Publisher.exchange" class="reference internal" href="#carrot.messaging.Publisher.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Publisher.routing_key" class="reference internal" href="#carrot.messaging.Publisher.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>encoder</em> &#8211; see <a title="carrot.messaging.Publisher.encoder" class="reference internal" href="#carrot.messaging.Publisher.encoder"><tt class="xref docutils literal"><span class="pre">encoder</span></tt></a>.</li>
<li><em>backend</em> &#8211; see <a title="carrot.messaging.Publisher.backend" class="reference internal" href="#carrot.messaging.Publisher.backend"><tt class="xref docutils literal"><span class="pre">backend</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Publisher.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Publisher.connection" title="Permalink to this definition">¶</a></dt>
<dd>The AMQP connection. A <a title="carrot.connection.AMQPConnection" class="reference external" href="carrot.connection.html#carrot.connection.AMQPConnection"><tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt></a>
instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Publisher.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange we send messages to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Publisher.routing_key" title="Permalink to this definition">¶</a></dt>
<dd>The routing key added to all messages sent using this publisher.
See <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">Consumer.routing_key</span></tt></a> for more information.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.delivery_mode">
<tt class="descname">delivery_mode</tt><a class="headerlink" href="#carrot.messaging.Publisher.delivery_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The default delivery mode used for messages. The value is an integer.
The following delivery modes are supported by (at least) RabbitMQ:</p>
<blockquote>
<ul>
<li><p class="first">1</p>
<blockquote>
<p>The message is non-persistent. Which means it is stored in
memory only, and is lost if the server dies or restarts.</p>
</blockquote>
</li>
<li><dl class="first docutils">
<dt>2</dt>
<dd><p class="first last">The message is persistent. Which means the message is
stored both in-memory, and on disk, and therefore
preserved if the server dies or restarts.</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<p>The default value is <tt class="docutils literal"><span class="pre">2</span></tt> (persistent).</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.encoder">
<tt class="descname">encoder</tt><a class="headerlink" href="#carrot.messaging.Publisher.encoder" title="Permalink to this definition">¶</a></dt>
<dd>The function responsible for encoding the message data passed
to <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">send()</span></tt></a>. Note that any consumer of the messages sent
must have a decoder supporting the serialization scheme.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.backend">
<tt class="descname">backend</tt><a class="headerlink" href="#carrot.messaging.Publisher.backend" title="Permalink to this definition">¶</a></dt>
<dd>The backend used. Defaults to the <tt class="docutils literal"><span class="pre">pyamqplib</span></tt> backend.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.close" title="Permalink to this definition">¶</a></dt>
<dd>Close connection to queue.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.create_message">
<tt class="descname">create_message</tt><big>(</big><em>message_data</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.create_message" title="Permalink to this definition">¶</a></dt>
<dd>With any data, serialize it and encapsulate it in a AMQP
message with the proper headers set.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>message_data</em> &#8211; The message data to send. Can be a list,
dictionary or a string.</li>
<li><em>delivery_mode</em> &#8211; Override the default <a title="carrot.messaging.Publisher.delivery_mode" class="reference internal" href="#carrot.messaging.Publisher.delivery_mode"><tt class="xref docutils literal"><span class="pre">delivery_mode</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


	      </div>
	    </div>
	  </div>
	</div>
	<div class="sidebar">
	  <h3>Contents</h3>
	  <ul class="current">
<li class="toctree-l1"><a class="reference external" href="../introduction.html">carrot - AMQP Messaging Framework for Python</a></li>
<li class="toctree-l1 current"><a class="reference external" href="index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference external" href="carrot.connection.html">carrot.connection</a></li>
<li class="toctree-l2 current"><a class="current reference external" href="">carrot.messaging</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.html">carrot.backends</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.base.html">carrot.backends.base</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.pyamqplib.html">carrot.backends.pyamqplib</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.queue.html">carrot.backends.queue</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.serialization.html">carrot.serialization</a></li>
</ul>
</li>
</ul>

	  <h3 style="margin-top: 1.5em;">Search</h3>
	  <form class="search" action="../search.html" method="get">
            <input type="text" name="q" size="18" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
	</div>
	<div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
	<div class="left">
          <a href="../genindex.html" title="General Index"
             >index</a> |
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |
          <a href="carrot.backends.html" title="carrot.backends"
             >next</a> |
          <a href="carrot.connection.html" title="carrot.connection"
             >previous</a>
            <br/>
            <a href="../sources/reference/carrot.messaging.txt"
               rel="nofollow">Show Source</a>
	</div>

	<div class="right">
	  &copy; Copyright 2009, Ask Solem.<br/>
	  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
	</div>
	<div class="clearer"></div>
      </div>
    </div>

  </body>
</html>