<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>carrot.messaging &mdash; Carrot v0.3.9 documentation</title>
    <link rel="stylesheet" href="../static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    '../',
      VERSION:     '0.3.9',
      COLLAPSE_MODINDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="Carrot v0.3.9 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
    <link rel="prev" title="API Reference" href="index.html" /> 
  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
	<h1><a href="../index.html">Carrot v0.3.9 documentation</a></h1>
	<div class="rel">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a> |
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |
          <a href="index.html" title="API Reference"
             accesskey="P">previous</a>
	</div>
      </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
	<div class="document">
	  <div class="documentwrapper">
	    <div class="bodywrapper">
	      <div class="body">
		
  <div class="section" id="module-carrot.messaging">
<h1>carrot.messaging<a class="headerlink" href="#module-carrot.messaging" title="Permalink to this headline">¶</a></h1>
<div class="section" id="creating-a-connection">
<h2>Creating a connection<a class="headerlink" href="#creating-a-connection" title="Permalink to this headline">¶</a></h2>
<blockquote>
<p>If you&#8217;re using Django you can use the
<tt class="xref docutils literal"><span class="pre">carrot.connection.DjangoAMQPConnection</span></tt> class, by setting the
following variables in your <tt class="docutils literal"><span class="pre">settings.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">AMQP_SERVER</span> <span class="o">=</span> <span class="s">&quot;localhost&quot;</span>
<span class="n">AMQP_PORT</span> <span class="o">=</span> <span class="mf">5672</span>
<span class="n">AMQP_USER</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span>
<span class="n">AMQP_PASSWORD</span> <span class="o">=</span> <span class="s">&quot;secret&quot;</span>
<span class="n">AMQP_VHOST</span> <span class="o">=</span> <span class="s">&quot;/test&quot;</span>
</pre></div>
</div>
<p>Then create a connection by doing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">carrot.connection</span> <span class="kn">import</span> <span class="n">DjangoAMQPConnection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amqpconn</span> <span class="o">=</span> <span class="n">DjangoAMQPConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>If you&#8217;re not using Django, you can create a connection manually by using
<tt class="xref docutils literal"><span class="pre">carrot.messaging.AMQPConnection</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">carrot.connection</span> <span class="kn">import</span> <span class="n">AMQPConnection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amqpconn</span> <span class="o">=</span> <span class="n">AMQPConnection</span><span class="p">(</span><span class="n">hostname</span><span class="o">=</span><span class="s">&quot;localhost&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mf">5672</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">userid</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">vhost</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
</pre></div>
</div>
</blockquote>
</div>
<div class="section" id="sending-messages-using-a-publisher">
<h2>Sending messages using a Publisher<a class="headerlink" href="#sending-messages-using-a-publisher" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">carrot.messaging</span> <span class="kn">import</span> <span class="n">Publisher</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span> <span class="o">=</span> <span class="n">Publisher</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">amqpconn</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">exchange</span><span class="o">=</span><span class="s">&quot;feed&quot;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;importer&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s">&quot;import_feed&quot;</span><span class="p">:</span> <span class="s">&quot;http://cnn.com/rss/edition.rss&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="receiving-messages-using-a-consumer">
<h2>Receiving messages using a Consumer<a class="headerlink" href="#receiving-messages-using-a-consumer" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">carrot.messaging</span> <span class="kn">import</span> <span class="n">Consumer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">Consumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">amqpconn</span><span class="p">,</span> <span class="n">queue</span><span class="o">=</span><span class="s">&quot;feed&quot;</span><span class="p">,</span>
<span class="go">                        exchange=&quot;feed&quot;, routing_key=&quot;importer&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">import_feed_callback</span><span class="p">(</span><span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">feed_url</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;import_feed&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">feed_url</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">message</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>
<span class="gp">... </span>    <span class="c"># something importing this feed url</span>
<span class="gp">... </span>    <span class="c"># import_feed(feed_url)</span>
<span class="gp">... </span>    <span class="n">message</span><span class="o">.</span><span class="n">ack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">import_feed_callback</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into the consumer loop.</span>
</pre></div>
</div>
</div>
<div class="section" id="subclassing-the-messaging-classes">
<h2>Subclassing the messaging classes<a class="headerlink" href="#subclassing-the-messaging-classes" title="Permalink to this headline">¶</a></h2>
<p>The <a title="carrot.messaging.Consumer" class="reference internal" href="#carrot.messaging.Consumer"><tt class="xref docutils literal"><span class="pre">Consumer</span></tt></a>, and <a title="carrot.messaging.Publisher" class="reference internal" href="#carrot.messaging.Publisher"><tt class="xref docutils literal"><span class="pre">Publisher</span></tt></a> classes are also designed
for subclassing. Another way of defining the publisher and consumer is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">carrot.messaging</span> <span class="kn">import</span> <span class="n">Publisher</span><span class="p">,</span> <span class="n">Consumer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FeedPublisher</span><span class="p">(</span><span class="n">Publisher</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">exchange</span> <span class="o">=</span> <span class="s">&quot;feed&quot;</span>
<span class="gp">... </span>    <span class="n">routing_key</span> <span class="o">=</span> <span class="s">&quot;importer&quot;</span>
<span class="gp">... </span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">feed_import</span><span class="p">(</span><span class="n">feed_url</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">({</span><span class="s">&quot;action&quot;</span><span class="p">:</span> <span class="s">&quot;import_feed&quot;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="s">&quot;feed_url&quot;</span><span class="p">:</span> <span class="n">feed_url</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">FeedConsumer</span><span class="p">(</span><span class="n">Consumer</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">queue</span> <span class="o">=</span> <span class="s">&quot;feed&quot;</span>
<span class="gp">... </span>    <span class="n">exchange</span> <span class="o">=</span> <span class="s">&quot;feed&quot;</span>
<span class="gp">... </span>    <span class="n">routing_key</span> <span class="o">=</span> <span class="s">&quot;importer&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">action</span> <span class="o">=</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;action&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">action</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">message</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&quot;import_feed&quot;</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c"># something importing this feed</span>
<span class="gp">... </span>            <span class="c"># import_feed(message_data[&quot;feed_url&quot;])</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unknown action: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">action</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span> <span class="o">=</span> <span class="n">FeedPublisher</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">amqpconn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span><span class="o">.</span><span class="n">import_feed</span><span class="p">(</span><span class="s">&quot;http://cnn.com/rss/edition.rss&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">publisher</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">FeedConsumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">amqpconn</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into the consumer loop.</span>
</pre></div>
</div>
<dl class="class">
<dt id="carrot.messaging.Consumer">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Consumer</tt><big>(</big><em>connection</em>, <em>queue=None</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Message consumer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Consumer.connection" class="reference internal" href="#carrot.messaging.Consumer.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>queue</em> &#8211; see <a title="carrot.messaging.Consumer.queue" class="reference internal" href="#carrot.messaging.Consumer.queue"><tt class="xref docutils literal"><span class="pre">queue</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Consumer.exchange" class="reference internal" href="#carrot.messaging.Consumer.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>durable</em> &#8211; see <a title="carrot.messaging.Consumer.durable" class="reference internal" href="#carrot.messaging.Consumer.durable"><tt class="xref docutils literal"><span class="pre">durable</span></tt></a>.</li>
<li><em>auto_delete</em> &#8211; see <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.</li>
<li><em>exclusive</em> &#8211; see <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a>.</li>
<li><em>exchange_type</em> &#8211; see <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a>.</li>
<li><em>decoder</em> &#8211; see <a title="carrot.messaging.Consumer.decoder" class="reference internal" href="#carrot.messaging.Consumer.decoder"><tt class="xref docutils literal"><span class="pre">decoder</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Consumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Consumer.connection" title="Permalink to this definition">¶</a></dt>
<dd>A <tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt> instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.queue">
<tt class="descname">queue</tt><a class="headerlink" href="#carrot.messaging.Consumer.queue" title="Permalink to this definition">¶</a></dt>
<dd>Name of the queue.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange the queue binds to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Consumer.routing_key" title="Permalink to this definition">¶</a></dt>
<dd><p>The routing key (if any). The interpretation of the routing key
depends on the value of the <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a> attribute:</p>
<blockquote>
<ul>
<li><p class="first">direct exchange</p>
<blockquote>
<p>Matches if the routing key property of the message and
the <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a> attribute are identical.</p>
</blockquote>
</li>
<li><p class="first">fanout exchange</p>
<blockquote>
<p>Always matches, even if the binding does not have a key.</p>
</blockquote>
</li>
<li><p class="first">topic exchange</p>
<blockquote>
<p>Matches the routing key property of the message by a primitive
pattern matching scheme. The message routing key then consists
of words separated by dots (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>, like domain names), and
two special characters are available; star (<tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>) and hash
(<tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>). The star matches any word, and the hash matches
zero or more words. For example <tt class="docutils literal"><span class="pre">&quot;*.stock.#&quot;</span> <span class="pre">matches</span> <span class="pre">the</span>
<span class="pre">routing</span> <span class="pre">keys</span> <span class="pre">``&quot;usd.stock&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;eur.stock.db&quot;</span></tt> but not
<tt class="docutils literal"><span class="pre">&quot;stock.nasdaq&quot;</span></tt>.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.durable">
<tt class="descname">durable</tt><a class="headerlink" href="#carrot.messaging.Consumer.durable" title="Permalink to this definition">¶</a></dt>
<dd>Durable exchanges remain active when a server restarts. Non-durable
exchanges (transient exchanges) are purged when a server restarts.
Default is <tt class="xref docutils literal"><span class="pre">True</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_delete">
<tt class="descname">auto_delete</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_delete" title="Permalink to this definition">¶</a></dt>
<dd>If set, the exchange is deleted when all queues have finished
using it. Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exclusive">
<tt class="descname">exclusive</tt><a class="headerlink" href="#carrot.messaging.Consumer.exclusive" title="Permalink to this definition">¶</a></dt>
<dd>Exclusive queues may only be consumer from by the current connection.
When <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a> is on, this also implies <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.
Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange_type">
<tt class="descname">exchange_type</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange_type" title="Permalink to this definition">¶</a></dt>
<dd><p>AMQP defines four default exchange types (routing algorithms) that
covers most of the common messaging use cases. An AMQP broker can
also define additional exchange types, so see your message brokers
manual for more information about available exchange types.</p>
<blockquote>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>direct</p>
<blockquote>
Direct match between the routing key in the message, and the
routing criteria used when a queue is bound to this exchange.</blockquote>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>topic</p>
<blockquote>
Wildcard match between the routing key and the routing pattern
specified in the binding. The routing key is treated as zero
or more words delimited by <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> and supports special
wildcard characters. <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> matches a single word and <tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>
matches zero or more words.</blockquote>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>fanout</p>
<blockquote>
Queues are bound to this exchange with no arguments. Hence any
message sent to this exchange will be forwarded to all queues
bound to this exchange.</blockquote>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>headers</p>
<blockquote>
<p>Queues are bound to this exchange with a table of arguments
containing headers and values (optional). A special argument
named &#8220;x-match&#8221; determines the matching algorithm, where
<tt class="docutils literal"><span class="pre">&quot;all&quot;</span></tt> implies an <tt class="docutils literal"><span class="pre">AND</span></tt> (all pairs must match) and
<tt class="docutils literal"><span class="pre">&quot;any&quot;</span></tt> implies <tt class="docutils literal"><span class="pre">OR</span></tt> (at least one pair must match).</p>
<dl class="docutils">
<dt><em>NOTE</em>: carrot has poor support for header exchanges at</dt>
<dd>this point.</dd>
</dl>
</blockquote>
<p>This description of AMQP exchange types was shamelessly stolen
from the blog post <a class="reference external" href="http://bit.ly/amqp-exchange-types">AMQP in 10 minutes: Part 4</a> by
Rajith Attapattu. Recommended reading.</p>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.decoder">
<tt class="descname">decoder</tt><a class="headerlink" href="#carrot.messaging.Consumer.decoder" title="Permalink to this definition">¶</a></dt>
<dd>A function able to deserialize the message body.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.callbacks">
<tt class="descname">callbacks</tt><a class="headerlink" href="#carrot.messaging.Consumer.callbacks" title="Permalink to this definition">¶</a></dt>
<dd>List of registered callbacks to trigger when a message is received
by <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises amqplib.client_0_8.channel.AMQPChannelException:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the queue is
exclusive and the queue already exists and is owned by another
connection.</td>
</tr>
</tbody>
</table>
<p>Example Usage</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">Consumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">DjangoAMQPConnection</span><span class="p">(),</span>
<span class="gp">... </span>                    <span class="n">queue</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_message</span><span class="p">(</span><span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got message </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>            <span class="n">message</span><span class="o">.</span><span class="n">delivery_tag</span><span class="p">,</span> <span class="n">message_data</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">process_message</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into receive loop</span>
</pre></div>
</div>
<dl class="method">
<dt id="carrot.messaging.Consumer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the channel to the queue.</p>
<p>Any operation that requires a connection will re-establish the
connection even if close was called explicitly.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.discard_all">
<tt class="descname">discard_all</tt><big>(</big><em>filter=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.discard_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all waiting messages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>filter</em> &#8211; A filter function to only discard the messages this
filter returns.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the number of messages discarded.</td>
</tr>
</tbody>
</table>
<p><em>WARNING</em>: All incoming messages will be ignored and not processed.</p>
<p>Example using filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">waiting_feeds_only</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">message_data</span> <span class="o">=</span> <span class="n">simplejson</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">except</span><span class="p">:</span> <span class="c"># Should probably be more specific.</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;feed&quot;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.fetch">
<tt class="descname">fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the next message waiting on the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A <a title="carrot.messaging.Message" class="reference internal" href="#carrot.messaging.Message"><tt class="xref docutils literal"><span class="pre">Message</span></tt></a> instance,
or <tt class="xref docutils literal"><span class="pre">None</span></tt> if there&#8217;s no messages to be received.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterqueue">
<tt class="descname">iterqueue</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinite iterator yielding pending messages.</p>
<p>Obviously you shouldn&#8217;t consume the whole iterator at
once, without using a <tt class="docutils literal"><span class="pre">limit</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>limit</em> &#8211; If set, the iterator stops when it has processed
this number of messages in total.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.message_to_python">
<tt class="descname">message_to_python</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.message_to_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode encoded message back to python.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>message</em> &#8211; A <a title="carrot.messaging.Message" class="reference internal" href="#carrot.messaging.Message"><tt class="xref docutils literal"><span class="pre">Message</span></tt></a> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.next" title="Permalink to this definition">¶</a></dt>
<dd><em>DEPRECATED</em>: Process the next pending message.
Deprecated in favour of <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.process_next">
<tt class="descname">process_next</tt><big>(</big><em>ack=True</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.process_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Processes the next pending message on the queue.</p>
<p>This function tries to fetch a message from the queue, and
if successful passes the message on to <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>ack</em> &#8211; By default, an ack is sent to the server
signifying that the message has been accepted. This means
that the <a title="carrot.messaging.Message.ack" class="reference internal" href="#carrot.messaging.Message.ack"><tt class="xref docutils literal"><span class="pre">Message.ack()</span></tt></a> and <a title="carrot.messaging.Message.reject" class="reference internal" href="#carrot.messaging.Message.reject"><tt class="xref docutils literal"><span class="pre">Message.reject()</span></tt></a> methods
on the message object are no longer valid.
If the ack argument is set to <tt class="xref docutils literal"><span class="pre">False</span></tt>, this behaviour is
disabled and the receiver is required to manually handle
acknowledgment.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The resulting <a title="carrot.messaging.Message" class="reference internal" href="#carrot.messaging.Message"><tt class="xref docutils literal"><span class="pre">Message</span></tt></a> object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a new message is received by 
running <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</p>
<p>When a message is received, it passes the message on to the
callbacks listed in the <a title="carrot.messaging.Consumer.callbacks" class="reference internal" href="#carrot.messaging.Consumer.callbacks"><tt class="xref docutils literal"><span class="pre">callbacks</span></tt></a> attribute.
You can register callbacks using <a title="carrot.messaging.Consumer.register_callback" class="reference internal" href="#carrot.messaging.Consumer.register_callback"><tt class="xref docutils literal"><span class="pre">register_callback()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>message_data</em> &#8211; The deserialized message data.</li>
<li><em>message</em> &#8211; The <a title="carrot.messaging.Message" class="reference internal" href="#carrot.messaging.Message"><tt class="xref docutils literal"><span class="pre">Message</span></tt></a> instance.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises NotImplementedError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If no callbacks has been registered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be triggered by <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">callback</span></tt> function must take two arguments:</p>
<blockquote>
<ul>
<li><p class="first">message_data</p>
<blockquote>
<p>The deserialized message data</p>
</blockquote>
</li>
<li><p class="first">message</p>
<blockquote>
<p>The <a title="carrot.messaging.Message" class="reference internal" href="#carrot.messaging.Message"><tt class="xref docutils literal"><span class="pre">Message</span></tt></a> instance.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Go into consume mode.</p>
<p>This runs an infinite loop, processing all incoming messages
using <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a> to apply the message to all registered
callbacks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Message">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Message</tt><big>(</big><em>amqp_message</em>, <em>channel</em>, <em>decoder=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Message" title="Permalink to this definition">¶</a></dt>
<dd><p>A message received by the broker.</p>
<p>Usually you don&#8217;t insantiate message objects yourself, but receive
them using a <a title="carrot.messaging.Consumer" class="reference internal" href="#carrot.messaging.Consumer"><tt class="xref docutils literal"><span class="pre">Consumer</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>amqp_message</em> &#8211; see <a title="carrot.messaging.Message.amqp_message" class="reference internal" href="#carrot.messaging.Message.amqp_message"><tt class="xref docutils literal"><span class="pre">amqp_message</span></tt></a>.</li>
<li><em>channel</em> &#8211; see <a title="carrot.messaging.Message.channel" class="reference internal" href="#carrot.messaging.Message.channel"><tt class="xref docutils literal"><span class="pre">channel</span></tt></a>.</li>
<li><em>decoder</em> &#8211; see <a title="carrot.messaging.Message.decoder" class="reference internal" href="#carrot.messaging.Message.decoder"><tt class="xref docutils literal"><span class="pre">decoder</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Message.amqp_message">
<tt class="descname">amqp_message</tt><a class="headerlink" href="#carrot.messaging.Message.amqp_message" title="Permalink to this definition">¶</a></dt>
<dd>A <tt class="xref docutils literal"><span class="pre">amqplib.client_0_8.basic_message.Message</span></tt> instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Message.channel">
<tt class="descname">channel</tt><a class="headerlink" href="#carrot.messaging.Message.channel" title="Permalink to this definition">¶</a></dt>
<dd>The AMQP channel. A <tt class="xref docutils literal"><span class="pre">amqplib.client_0_8.channel.Channel</span></tt> instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Message.decoder">
<tt class="descname">decoder</tt><a class="headerlink" href="#carrot.messaging.Message.decoder" title="Permalink to this definition">¶</a></dt>
<dd>A function able to deserialize the serialized message data.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Message.ack">
<tt class="descname">ack</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Message.ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledge this message as being processed.,</p>
<p>This will remove the message from the queue.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Message.body">
<tt class="descname">body</tt><a class="headerlink" href="#carrot.messaging.Message.body" title="Permalink to this definition">¶</a></dt>
<dd>The message body.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Message.decode">
<tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Message.decode" title="Permalink to this definition">¶</a></dt>
<dd>Deserialize the message body, returning the original
python structure sent by the publisher.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Message.delivery_tag">
<tt class="descname">delivery_tag</tt><a class="headerlink" href="#carrot.messaging.Message.delivery_tag" title="Permalink to this definition">¶</a></dt>
<dd>The message delivery tag, uniquely identifying this message.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Message.reject">
<tt class="descname">reject</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Message.reject" title="Permalink to this definition">¶</a></dt>
<dd><p>Reject this message.</p>
<p>The message will be discarded by the server.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Message.requeue">
<tt class="descname">requeue</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Message.requeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Reject this message and put it back on the queue.</p>
<p>You must not use this method as a means of selecting messages
to process.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Messaging">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Messaging</tt><big>(</big><em>connection</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging" title="Permalink to this definition">¶</a></dt>
<dd><p>A message publisher and consumer.</p>
<dl class="attribute">
<dt id="carrot.messaging.Messaging.consumer_cls">
<tt class="descname">consumer_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.consumer_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Consumer" class="reference internal" href="#carrot.messaging.Consumer"><tt class="xref docutils literal"><span class="pre">Consumer</span></tt></a></dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.publisher_cls">
<tt class="descname">publisher_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.publisher_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Publisher" class="reference internal" href="#carrot.messaging.Publisher"><tt class="xref docutils literal"><span class="pre">Publisher</span></tt></a></dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Publisher">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Publisher</tt><big>(</big><em>connection</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Message publisher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Publisher.connection" class="reference internal" href="#carrot.messaging.Publisher.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Publisher.exchange" class="reference internal" href="#carrot.messaging.Publisher.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Publisher.routing_key" class="reference internal" href="#carrot.messaging.Publisher.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>encoder</em> &#8211; see <a title="carrot.messaging.Publisher.encoder" class="reference internal" href="#carrot.messaging.Publisher.encoder"><tt class="xref docutils literal"><span class="pre">encoder</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Publisher.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Publisher.connection" title="Permalink to this definition">¶</a></dt>
<dd>The AMQP connection. A <tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt>
instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Publisher.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange we send messages to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Publisher.routing_key" title="Permalink to this definition">¶</a></dt>
<dd>The routing key added to all messages sent using this publisher.
See <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">Consumer.routing_key</span></tt></a> for more information.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.delivery_mode">
<tt class="descname">delivery_mode</tt><a class="headerlink" href="#carrot.messaging.Publisher.delivery_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The default delivery mode used for messages. The value is an integer.
The following delivery modes are supported by (at least) RabbitMQ:</p>
<blockquote>
<ul>
<li><p class="first">1</p>
<blockquote>
<p>The message is non-persistent. Which means it is stored in
memory only, and is lost if the server dies or restarts.</p>
</blockquote>
</li>
<li><dl class="first docutils">
<dt>2</dt>
<dd><p class="first last">The message is persistent. Which means the message is
stored both in-memory, and on disk, and therefore
preserved if the server dies or restarts.</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<p>The default value is <tt class="docutils literal"><span class="pre">2</span></tt> (persistent).</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.encoder">
<tt class="descname">encoder</tt><a class="headerlink" href="#carrot.messaging.Publisher.encoder" title="Permalink to this definition">¶</a></dt>
<dd>The function responsible for encoding the message data passed
to <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">send()</span></tt></a>. Note that any consumer of the messages sent
must have a decoder supporting the serialization scheme.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close connection to queue.</p>
<p><em>Note</em> Whenever <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">send()</span></tt></a> is called, the connection is
re-established, even if <a title="carrot.messaging.Publisher.close" class="reference internal" href="#carrot.messaging.Publisher.close"><tt class="xref docutils literal"><span class="pre">close()</span></tt></a> was called explicitly.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.create_message">
<tt class="descname">create_message</tt><big>(</big><em>message_data</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.create_message" title="Permalink to this definition">¶</a></dt>
<dd>With any data, serialize it and encapsulate it in a AMQP
message with the proper headers set.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>message_data</em> &#8211; The message data to send. Can be a list,
dictionary or a string.</li>
<li><em>delivery_mode</em> &#8211; Override the default <a title="carrot.messaging.Publisher.delivery_mode" class="reference internal" href="#carrot.messaging.Publisher.delivery_mode"><tt class="xref docutils literal"><span class="pre">delivery_mode</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


	      </div>
	    </div>
	  </div>
	</div>
	<div class="sidebar">
	  <h3>Contents</h3>
	  <ul class="current">
<li class="toctree-l1"><a class="reference external" href="../introduction.html">carrot - Simple RabbitMQ/ZeroMQ (AMQP) messaging queue support for Python/Django.</a></li>
<li class="toctree-l1 current"><a class="reference external" href="index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference external" href="">carrot.messaging</a><ul>
<li class="toctree-l3"><a class="reference external" href="#creating-a-connection">Creating a connection</a></li>
<li class="toctree-l3"><a class="reference external" href="#sending-messages-using-a-publisher">Sending messages using a Publisher</a></li>
<li class="toctree-l3"><a class="reference external" href="#receiving-messages-using-a-consumer">Receiving messages using a Consumer</a></li>
<li class="toctree-l3"><a class="reference external" href="#subclassing-the-messaging-classes">Subclassing the messaging classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

	  <h3 style="margin-top: 1.5em;">Search</h3>
	  <form class="search" action="../search.html" method="get">
            <input type="text" name="q" size="18" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
	</div>
	<div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
	<div class="left">
          <a href="../genindex.html" title="General Index"
             >index</a> |
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |
          <a href="index.html" title="API Reference"
             >previous</a>
            <br/>
            <a href="../sources/reference/carrot.messaging.txt"
               rel="nofollow">Show Source</a>
	</div>

	<div class="right">
	  &copy; Copyright 2009, Ask Solem.<br/>
	  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
	</div>
	<div class="clearer"></div>
      </div>
    </div>

  </body>
</html>